import{_ as a,c as t,o,ag as i}from"./chunks/framework.B-XtCDNB.js";const l="/assets/valac-link.BgwJb8t4.png",n="/assets/valac-data.DutHm_-f.png",g=JSON.parse('{"title":"3.1. Vala in a Nutshell","description":"","frontmatter":{},"headers":[],"relativePath":"contributor-guide/compiler-guide/03-00-the-vala-compiler/03-01-vala-in-a-nutshell.md","filePath":"contributor-guide/compiler-guide/03-00-the-vala-compiler/03-01-vala-in-a-nutshell.md","lastUpdated":1763236341000}'),r={name:"contributor-guide/compiler-guide/03-00-the-vala-compiler/03-01-vala-in-a-nutshell.md"};function s(c,e,d,h,p,m){return o(),t("div",null,[...e[0]||(e[0]=[i('<h1 id="_3-1-vala-in-a-nutshell" tabindex="-1">3.1. Vala in a Nutshell <a class="header-anchor" href="#_3-1-vala-in-a-nutshell" aria-label="Permalink to &quot;3.1. Vala in a Nutshell&quot;">​</a></h1><p>The Vala compiler <strong>valac</strong> is a small shell around libvala which handles command-line arguments, locates the sources and libraries which are required, and drives the compilation procedure.</p><p><strong>How valac is linked</strong></p><p><img src="'+l+'" alt="How valac is linked"></p><p>All the important work such as parsing, error checking/reporting, code generation, calling <strong>gcc</strong>, is done in libvala.</p><p>The code for <strong>valac</strong> can be found in <code>compiler/valacompiler.vala</code>.</p><h2 id="_3-1-1-command-line-options" tabindex="-1">3.1.1. Command-line Options <a class="header-anchor" href="#_3-1-1-command-line-options" aria-label="Permalink to &quot;3.1.1. Command-line Options&quot;">​</a></h2><p>These are handled in the normal way by the Vala binding to <em>GLib.OptionContext</em>. Most of the instance variables in Vala.Compiler are referenced in the options array. It&#39;s not very interesting.</p><h2 id="_3-1-2-the-compilation-procedure-and-vala-codecontext" tabindex="-1">3.1.2. The Compilation Procedure and Vala.CodeContext <a class="header-anchor" href="#_3-1-2-the-compilation-procedure-and-vala-codecontext" aria-label="Permalink to &quot;3.1.2. The Compilation Procedure and Vala.CodeContext&quot;">​</a></h2><p>Vala.Compiler plugs together the classes of libvala in a big pipeline. This modular design makes Vala more maintainable and external tools can easily use this code.</p><h2 id="_3-1-3-the-valac-pipeline" tabindex="-1">3.1.3. The valac Pipeline <a class="header-anchor" href="#_3-1-3-the-valac-pipeline" aria-label="Permalink to &quot;3.1.3. The valac Pipeline&quot;">​</a></h2><ol><li>Initialize CodeContext with command-line options.</li><li>Add packages from command-line and others depending on the profile.</li><li>Add sources, Vala, Genie, Gir, VAPI, and C from command-line.</li><li>Parse everything.</li><li>Resolve symbols.</li><li>Run the Semantic Analyzer.</li><li>Run the Flow Analyzer.</li><li>Use the code generator to emit code.</li><li>Write out VAPI and GIDL files, if a library is being compiled.</li><li>Compile the generated C code.</li></ol><p>The individual steps will be explained later, but first <code>Vala.CodeContext</code>, the data structure which holds everything together. It stores the compile options which were specified on the command line, and a list of source files to compile. There is only one <code>CodeContext</code> instantiated and its reference is passed around a lot, so effectively it&#39;s a global variable.</p><p>Vala.CodeContext is the root of the code tree, because it contains the root Namespace, which holds references to all parsed code nodes. In addition to the code tree, the context contains a reference to a code generator object. This object walks the code tree and generates code.</p><p>Vala.CodeContext contains an important method called <code>accept</code>, which initiates a depth-first traversal of the code tree. This method, and the CodeVisitor pattern will be discussed later.</p><p><strong>Data diagram</strong></p><p><img src="'+n+'" alt="Data diagram"></p><p>The Vala code tree is an abstract syntax tree (AST) built by parsing the Vala sources. For example, if you see a class called <code>Vala.Destructor</code> which inherits <code>Vala.Symbol</code>, then it is a part of the AST. Data structures for the AST and the parser which builds it are in the <code>vala</code> directory.</p><p>Vala also uses a tree to represent the C <code>ccode</code> that will be output. Data structures for the C code (CCode classes) tree are in the <code>ccode</code> directory.</p><p>The machinery which transforms the Vala AST into a C code tree is in the <code>codegen</code> directory arranged in a modular visitor. The AST is traversed and a CCode tree is created.</p><p>Vala is split upon these lines, most probably to break the system into conceptually-related, understandable chunks. However, with suitable modifications, the different modules could be replaced. Conceivably, Vala could produce non-GObject C code. More realistically, Vala could produce intermediate code as a <a href="http://gcc.gnu.org/frontends.html" target="_blank" rel="noreferrer">GCC frontend</a>.</p>',21)])])}const b=a(r,[["render",s]]);export{g as __pageData,b as default};
