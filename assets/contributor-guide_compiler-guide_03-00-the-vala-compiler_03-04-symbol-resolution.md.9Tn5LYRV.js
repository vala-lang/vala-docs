import{_ as s,c as a,o as t,ag as i}from"./chunks/framework.B-XtCDNB.js";const y=JSON.parse('{"title":"3.4. Symbol Resolution","description":"","frontmatter":{},"headers":[],"relativePath":"contributor-guide/compiler-guide/03-00-the-vala-compiler/03-04-symbol-resolution.md","filePath":"contributor-guide/compiler-guide/03-00-the-vala-compiler/03-04-symbol-resolution.md","lastUpdated":1762883246000}'),o={name:"contributor-guide/compiler-guide/03-00-the-vala-compiler/03-04-symbol-resolution.md"};function l(n,e,r,p,h,c){return t(),a("div",null,[...e[0]||(e[0]=[i(`<h1 id="_3-4-symbol-resolution" tabindex="-1">3.4. Symbol Resolution <a class="header-anchor" href="#_3-4-symbol-resolution" aria-label="Permalink to &quot;3.4. Symbol Resolution&quot;">​</a></h1><p>Vala.SymbolResolver is a CodeVisitor that exchanges Vala.UnresolvedTypes in the parse tree with Vala.DataTypes and links Vala.NamespaceReferences with the correct namespace symbol. Additionally, it checks base types for classes so that classes don&#39;t inherit from multiple classes or themselves, and likewise it checks that interfaces don&#39;t need to implement themselves.</p><h2 id="_3-4-1-data-types" tabindex="-1">3.4.1. Data Types <a class="header-anchor" href="#_3-4-1-data-types" aria-label="Permalink to &quot;3.4.1. Data Types&quot;">​</a></h2><p>Every expression has a static type. This is computed by the semantic analyzer. Vala.DataType is called a &quot;type reference&quot; because it contains a reference to a Vala.Typesymbol (a class, interface, etc) as well as information about the expression&#39;s type e.g. if it can be null, if it&#39;s an out parameter.</p><div class="info custom-block"><p class="custom-block-title">TODO</p><p>expand this section</p></div><h2 id="_3-4-2-symbols" tabindex="-1">3.4.2. Symbols <a class="header-anchor" href="#_3-4-2-symbols" aria-label="Permalink to &quot;3.4.2. Symbols&quot;">​</a></h2><p>A Vala.Symbol is a specialization of Vala.CodeNode. All symbols except for the root symbol are contained within another&#39;s scope. Types have scope and variables have scope. For types and variables, scope determines their accessibility, subject to access modifiers. For variables, scope also determines their lifetime. As the code tree is traversed, SymbolResolver keeps track of the current scope. For example, when a class is visited, current_scope is set to that class&#39;s scope.</p><p>When the parser parses a type, e.g. in the statement Gtk.Window main_window;, the type Gtk.Window is initially a Vala.UnresolvedType. In visit_data_type(), the UnresolvedType code node asks its parent to replace it with a new Vala.DataType created with resolve_type().</p><p>UnresolvedTypes have UnresolvedSymbols. resolve_type() uses resolve_symbol() to find the Typesymbol referred to, and then wraps it in a new DataType object.</p><p>resolve_symbol() is a recursive method which looks up an unresolved symbol&#39;s name in the current scope and returns the corresponding Typesymbol. The base case is when the UnresolvedSymbol has no qualifiers, e.g. Window. The recursive case is when the symbol looks like Gtk.Window or Gtk.Orientation.HORIZONTAL. In Vala.Parser.parse_symbol_name(), the symbol is built inside-out, so Gtk.Orientation.HORIZONTAL is parsed as:</p><div class="language-vala vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vala</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UnresolvedSymbol</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UnresolvedSymbol</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">UnresolvedSymbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Gtk&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">         &quot;Orientation&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">     &quot;HORIZONTAL&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>This is inside-out because Orientation is the parent scope of HORIZONTAL, but Orientation is the child node of HORIZONTAL.</p><p>In the base case, the symbol&#39;s name is looked up in current_scope. If the symbol is not found there, then the scope of all imported namespaces is searched. If more than one imported namespace contains the symbol, an &quot;ambiguous reference&quot; error will be reported.</p><p>In the recursive case, resolve_symbol() is called on the child node to give a parent scope, in which the symbol is looked up.</p><p>One last function of SymbolResolver is in visit_variable_declarator() - to mark a variable type reference as &quot;nullable&quot; if the variable&#39;s type is a class, interface, array or error (reference type). This is used later by Vala.NullChecker.</p>`,15)])])}const m=s(o,[["render",l]]);export{y as __pageData,m as default};
