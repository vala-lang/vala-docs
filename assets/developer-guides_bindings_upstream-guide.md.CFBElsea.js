import{_ as a,c as i,o as t,ag as s}from"./chunks/framework.B-XtCDNB.js";const u=JSON.parse('{"title":"Why Distribute Bindings Upstream","description":"","frontmatter":{},"headers":[],"relativePath":"developer-guides/bindings/upstream-guide.md","filePath":"developer-guides/bindings/upstream-guide.md","lastUpdated":1761243551000}'),n={name:"developer-guides/bindings/upstream-guide.md"};function o(r,e,l,h,p,d){return t(),i("div",null,[...e[0]||(e[0]=[s(`<h1 id="why-distribute-bindings-upstream" tabindex="-1">Why Distribute Bindings Upstream <a class="header-anchor" href="#why-distribute-bindings-upstream" aria-label="Permalink to &quot;Why Distribute Bindings Upstream&quot;">​</a></h1><p>While a number of bindings for third-party libraries are maintained as part of Vala itself, this is not the recommended method for providing Vala bindings. When possible, projects are encouraged to distribute their own Vala bindings. Doing so provides a number of advantages to both you and your users, including:</p><h2 id="catch-errors-earlier" tabindex="-1">Catch errors earlier <a class="header-anchor" href="#catch-errors-earlier" aria-label="Permalink to &quot;Catch errors earlier&quot;">​</a></h2><p>In order to find problems with most GObject Introspection bindings you must actually write code to test that code path. Since vapigen generates a VAPI for an entire API ahead of time it will help you detect many common problems, such as mismatched methods and virtual methods. Furthermore, since VAPIs are much easier to read than GIR XML, taking a quick look at the generated VAPI when changing API can help you spot bugs before they even make it into your repository.</p><h2 id="annotation-bugs-get-fixed-quicker" tabindex="-1">Annotation bugs get fixed quicker <a class="header-anchor" href="#annotation-bugs-get-fixed-quicker" aria-label="Permalink to &quot;Annotation bugs get fixed quicker&quot;">​</a></h2><p>Vala users will often find bugs which aren&#39;t actually specific to the Vala bindings, but rather exist in any GObject Introspection consumer. Distributing bindings with your library means you will receive bug reports about such issues sooner.</p><h2 id="matching-the-version-of-the-installed-software" tabindex="-1">Matching the version of the installed software <a class="header-anchor" href="#matching-the-version-of-the-installed-software" aria-label="Permalink to &quot;Matching the version of the installed software&quot;">​</a></h2><p>When bindings are distributed with Vala, or externally, it&#39;s unlikely the version of your software the bindings are targeted at is the same as the version that is actually installed. Bindings which are targeted at an older release may not expose features present in the newer version, and bindings targeted at a newer release may result in C compiler errors.</p><h2 id="higher-quality-bindings" tabindex="-1">Higher quality bindings <a class="header-anchor" href="#higher-quality-bindings" aria-label="Permalink to &quot;Higher quality bindings&quot;">​</a></h2><p>You know your library better than the Vala developers do and you can make sure your APIs look, and behave, as you intended.</p><h2 id="api-documentation" tabindex="-1">API documentation <a class="header-anchor" href="#api-documentation" aria-label="Permalink to &quot;API documentation&quot;">​</a></h2><p>We provide documentation for many libraries which ship a VAPI on <a href="https://www.valadoc.org/" target="_blank" rel="noreferrer">Valadoc.org</a>.</p><p><strong>But...</strong></p><h2 id="why-not-use-gobject-introspection-directly" tabindex="-1">Why not use GObject Introspection directly? <a class="header-anchor" href="#why-not-use-gobject-introspection-directly" aria-label="Permalink to &quot;Why not use GObject Introspection directly?&quot;">​</a></h2><p>Sometimes it can, but we generally discourage it for several reasons. Obviously, you&#39;ll no longer receive the benefits mentioned in the preceding section, but there are also several problems that occur for people attempting to consume your API in Vala.</p><p>Using a GIRs directly tends to cause people to use other GIRs directly, either on accident or because they believe there is nothing wrong with doing so, but even if your GIR doesn&#39;t require any metadata others likely will. For example, if your GIR includes Gio-2.0 and the user doesn&#39;t pass --pkg gio-2.0, the GIR for GIO will be included automatically by the compiler instead of the VAPI. GIO is one of those libraries which does require metadata, and valac will exit with an error. These issues can be circumvented by passing the appropriate flags to valac, although this can be a bit confusing for users who expect valac automatically handle dependencies for them.</p><p>GObject Introspection also allows for some things which Vala does not, which is where the real problems begin. These issues can cause errors from Vala&#39;s GIR parser (like the ones mentioned earier from GIO), resulting in your GIR being useless to valac. The classic example of this is duplicate symbols; GObject Introspection allows for methods, virtual methods, and signals with the same name but different signatures to coexist, whereas Vala does not.</p><p>In general, Vala allows for much more API to be exposed than what GObject Introspection allows for, including generics (other than the ones built into glib), variadic arguments, default values, non-GObject inheritance, and much more. Not distributing a VAPI can deprive Vala consumers of many extremely interesting features.</p><p>Those libraries who choose not to distribute a VAPI are likely to end up eventually shipping a GIR which causes errors for Vala, breaking working applications.</p><h2 id="i-don-t-know-anything-about-vala-or-vala-bindings" tabindex="-1">I Don&#39;t Know Anything About Vala (or Vala Bindings) <a class="header-anchor" href="#i-don-t-know-anything-about-vala-or-vala-bindings" aria-label="Permalink to &quot;I Don&#39;t Know Anything About Vala (or Vala Bindings)&quot;">​</a></h2><p>Don&#39;t worry about it. The people who maintain Vala are happy to help maintain bindings distributed upstream. After all, it isn&#39;t really any more effort to fix something in your repository than in Vala&#39;s. Just drop by the <a href="https://matrix.to/#/#vala:gnome.org" target="_blank" rel="noreferrer">Vala Matrix Room</a>.</p><h2 id="how-vala-bindings-work" tabindex="-1">How Vala Bindings Work <a class="header-anchor" href="#how-vala-bindings-work" aria-label="Permalink to &quot;How Vala Bindings Work&quot;">​</a></h2><p>Vala bindings tend to be much smaller, and simpler, than those for traditional languages such as Python, PHP, and even C++. This is because instead of creating functions which will convert between the C API you want to use and the data structures used natively by your language of choice Vala simply uses the C API directly.</p><p>The names of Vala bindings correspond to <a href="http://www.freedesktop.org/wiki/Software/pkg-config" target="_blank" rel="noreferrer">pkg-config</a> files, which allows valac to build and link software without any information other than the code to compile and a list of packages to use. All (one or two) of the files which should be distributed are simply the pkg-config name and an extension.</p><p>The only required file is a VAPI, which tells valac how to map Vala code to C. Sometimes these files are handwritten, but where <a href="https://gi.readthedocs.io/en/latest/index.html" target="_blank" rel="noreferrer">GObject Introspection</a> support is available the bindings can be automatically generated from a GIR. For examples of VAPI files, please see <a href="http://git.gnome.org/browse/vala/tree/vapi" target="_blank" rel="noreferrer">the bindings distributed with Vala</a>.</p><p>The only other file that should be distributed is a <em>deps</em> file, which lists <em>pkg-config</em> names of any dependencies exposed in the public API. Although not technically required, this file helps avoid confusing errors about undefined symbols.</p><p>There are three methods for creating a VAPI, one of which (generation from GIDL) is deprecated and shall not be described in this document. The easy way to generate a VAPI is by using vapigen to create one from a GObject Introspection Repository (GIR). When that is not possible, you can always write the VAPI by hand.</p><h2 id="generating-a-vapi-from-gobject-introspection" tabindex="-1">Generating a VAPI from GObject Introspection <a class="header-anchor" href="#generating-a-vapi-from-gobject-introspection" aria-label="Permalink to &quot;Generating a VAPI from GObject Introspection&quot;">​</a></h2><p>If your library is based on GObject, you will probably want to use <a href="https://gi.readthedocs.io/en/latest/index.html" target="_blank" rel="noreferrer">GObject Introspection</a>. Besides being the easiest way to get Vala bindings, you also get bindings for a growing number of other languages and most of the maintenance burden is shared.</p><h3 id="generating-a-gir" tabindex="-1">Generating a GIR <a class="header-anchor" href="#generating-a-gir" aria-label="Permalink to &quot;Generating a GIR&quot;">​</a></h3><p>The first step to generating Vala bindings from a GIR is to make sure you have a GIR. A GIR can be generated from source code using <em>g-ir-scanner</em>. Documentation for <a href="https://gi.readthedocs.io/en/latest/buildsystems/autotoolsintegration.html" target="_blank" rel="noreferrer">integration with autotools is available</a></p><p>The GObject introspection team provides lots of information on <a href="https://gi.readthedocs.io/en/latest/index.html" target="_blank" rel="noreferrer">GObject Introspection</a> which will not be repeated here.</p><h3 id="generating-a-vapi-from-a-gir" tabindex="-1">Generating a VAPI from a GIR <a class="header-anchor" href="#generating-a-vapi-from-a-gir" aria-label="Permalink to &quot;Generating a VAPI from a GIR&quot;">​</a></h3><p>Once you have a GIR, you can get to work on generating a VAPI, which means executing vapigen. If the pkg-config name of your library were &quot;foo-1.0&quot;, it would look something like this:</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vapigen</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    --library</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> foo-1.0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    Foo-1.0.gir</span></span></code></pre></div><p>You will most likely also need to provide a list of dependencies to vapigen:</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">vapigen</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    --library</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> foo-1.0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    --pkg</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bar-1.0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> \\</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">    Foo-1.0.gir</span></span></code></pre></div><p>The VAPI generation process may require some further tweaking. This is done with a <em>.metadata</em> file passed to <em>vapigen</em>. Sometimes custom Vala code also needs to be passed. See <a href="./generating-a-vapi-with-gobject-introspection.html">Generating a VAPI with GObject Introspection</a>\` for more details.</p><h3 id="autotools-integration" tabindex="-1">Autotools Integration <a class="header-anchor" href="#autotools-integration" aria-label="Permalink to &quot;Autotools Integration&quot;">​</a></h3><p>Since version 0.16, Vala has provided autotools integration for vapigen similar to what GI provides for g-ir-scanner in the form of an autoconf macro and a Makefile. In order to avoid introducing a hard dependency to your project, it is recommended you copy the <a href="https://gitlab.gnome.org/GNOME/vala/-/blob/master/vapigen/vapigen.m4" target="_blank" rel="noreferrer">vapigen.m4</a> file into your macro directory (usually an m4/ folder in the top level of your project). The macro has the following signature:</p><div class="language-shell vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">shell</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">VAPIGEN_CHECK([VERSION],</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [API_VERSION], [FOUND-INTROSPECTION], [DEFAULT])</span></span></code></pre></div><p>All four arguments are optional.</p><p>VERSION</p><blockquote><p>Require the specified version of vapigen in order for the test to pass. You can use this to make sure vapigen is as recent as you need it to be.</p></blockquote><p>API_VERSION</p><blockquote><p>Limit matches to the specified API version. This will cause the version specific vapidir to be used as the default installation location. You should not set this argument unless your vapi only works with a specific version of Vala.</p></blockquote><p>FOUND-INTROSPECTION</p><blockquote><p>Used to explicitly specify that GObject introspection support was found. Generally, you should omit this argument unless you are not using the GOBJECT_INTROSPECTION_CHECK macro from GI.</p></blockquote><p>DEFAULT</p><blockquote><p>The default value of the argument (yes, no, or auto). The default default is auto.</p></blockquote><p>This macro will define three variables for you to use in your automake files:</p><p>VAPIGEN</p><blockquote><p>Path to the vapigen executable</p></blockquote><p>VAPIGEN_VAPIDIR</p><blockquote><p>The location to install the your bindings to</p></blockquote><p>VAPIGEN_MAKEFILE</p><blockquote><p>The location of a Makefile you can include to help you generate the VAPI</p></blockquote><p>At this point, you can include <a href="https://gitlab.gnome.org/GNOME/vala/-/blob/master/vapigen/Makefile.vapigen" target="_blank" rel="noreferrer">Makefile.vapigen</a> to help you easily generate your VAPI. This should be done conditionally based on the ENABLE_VAPIGEN conditional:</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">if ENABLE_VAPIGEN</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> $(</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">VAPIGEN_MAKEFILE</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">endif</span></span></code></pre></div><p>The Makefile will make use of several variables which you should populate:</p><p>VAPIGEN_FILES</p><blockquote><p>A list of VAPIs to generate</p></blockquote><p>DEPS / VAPIGEN_DEPS</p><blockquote><p>List of dependencies. Usually these are pkg-config names so the VAPIs are used, but it is technically possible to use a raw GIR here, so long as no metadata is required to generate a VAPI from that GIR. Corresponds to the --pkg arguments.</p></blockquote><p>METADATADIRS / VAPIGEN_METADATADIRS</p><blockquote><p>List of directories containing the metadata files. Corresponds to the --metadatadir arguments.</p></blockquote><p>VAPIDIRS / VAPIGEN_VAPIDIRS</p><blockquote><p>List of directories to look for VAPI dependencies. Corresponds to the --vapidir arguments.</p></blockquote><p>GIRDIRS / VAPIGEN_GIRDIRS</p><blockquote><p>List of directories to look for GIR dependencies. Corresponds to the --girdir arguments. Note that this only specifies where vapigen will look for dependencies, not for the source files (i.e., files listed in *_FILES).</p></blockquote><p>FILES</p><blockquote><p>The GIR file to generate the VAPI from</p></blockquote><p>To use our &quot;Foo&quot; example from eariler:</p><div class="language-make vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">make</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">if ENABLE_VAPIGEN</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-include</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> $(</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">VAPIGEN_MAKEFILE</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo-1.0.vapi</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Foo-1.0.gir Foo-1.0-custom.vala foo-1.0.deps</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">VAPIGEN_VAPIS = foo-1.0.vapi</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">foo_1_0_vapi_DEPS = foo-1.0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">foo_1_0_vapi_METADATADIRS = </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">$(</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">srcdir</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">foo_1_0_vapi_FILES = Foo-1.0.gir Foo-1.0-custom.vala</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">vapidir = </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">$(</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">datadir</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/vala/vapi</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">vapi_DATA = </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">$(</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">VAPIGEN_VAPIS</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> $(</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">VAPIGEN_VAPIS:.vapi=.deps</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">EXTRA_DIST += Foo-1.0.metadata foo-1.0.deps Foo-1.0-custom.vala</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">endif</span></span></code></pre></div><h2 id="writing-a-vapi-by-hand" tabindex="-1">Writing a VAPI By Hand <a class="header-anchor" href="#writing-a-vapi-by-hand" aria-label="Permalink to &quot;Writing a VAPI By Hand&quot;">​</a></h2><p>If GObject Introspection support isn&#39;t an option for you, you can still write a VAPI by hand. The process isn&#39;t as easy as generating one from a GIR, but it is surprisingly easy for people who are already familiar with Vala. The syntax is the same as for Vala, but values and method bodies are omitted, and annotations (especially CCode annotations) are much more common. For a guide on how to convert a non-GLib C API to a Vala binding, see <a href="./writing-a-vapi-manually.html">Writing a VAPI Manually</a>.</p><h3 id="namespaces" tabindex="-1">Namespaces <a class="header-anchor" href="#namespaces" aria-label="Permalink to &quot;Namespaces&quot;">​</a></h3><p>VAPIs should enclose their API in a namespace. The namespace need not be unique but generally are. Nested namespaces can be used to further group similar functionality if desired.</p><h3 id="data-types" tabindex="-1">Data Types <a class="header-anchor" href="#data-types" aria-label="Permalink to &quot;Data Types&quot;">​</a></h3><p>The first step in writing a VAPI by hand is figuring out to represent your types in Vala. There is a graphic in the FAQ (under the <a href="./../../faq.html#what-does-simpletype-and-compact-in-bindings-mean">What does [SimpleType] and [Compact] in bindings mean?</a> question) which provides a good idea of when you should use which types.</p>`,80)])])}const g=a(n,[["render",o]]);export{u as __pageData,g as default};
