import{_ as e,c as s,o as i,ag as n}from"./chunks/framework.B-XtCDNB.js";const g=JSON.parse('{"title":"2.4. Create a Root Namespace","description":"","frontmatter":{},"headers":[],"relativePath":"developer-guides/bindings/writing-a-vapi-manually/02-00-getting-started/02-04-create-a-root-namespace.md","filePath":"developer-guides/bindings/writing-a-vapi-manually/02-00-getting-started/02-04-create-a-root-namespace.md","lastUpdated":1761243514000}'),t={name:"developer-guides/bindings/writing-a-vapi-manually/02-00-getting-started/02-04-create-a-root-namespace.md"};function o(l,a,p,r,d,c){return i(),s("div",null,[...a[0]||(a[0]=[n(`<h1 id="_2-4-create-a-root-namespace" tabindex="-1">2.4. Create a Root Namespace <a class="header-anchor" href="#_2-4-create-a-root-namespace" aria-label="Permalink to &quot;2.4. Create a Root Namespace&quot;">â€‹</a></h1><p>Normally all the bindings for a library are placed into a single root namespace. For example libfoo or foolib, would best be placed in a namespace called Foo. This follows the naming convention above. For example an initial VAPI would be:</p><div class="language-vala vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vala</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">namespace</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // bindings</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>The binding can then either be used in a Vala program by prefixing the namespace, e.g.:</p><div class="language-vala vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vala</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">library_function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>or bring the VAPI namespace into the scope of the file:</p><div class="language-vala vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vala</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">using</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    library_function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Namespaces also provide a convenient way to group functions. Typically, for GLib-based libraries, the <code>x_y_foo</code> patterns can be translated directly into a namespace as <code>x.y.foo</code>. Since most C libraries do not follow these conventions, things are slightly murkier. As general rules of thumb, try the following:</p><ul><li>Move global variables, functions, constants, enums, flags, and delegate definitions into the class and struct definitions if they are clearly related only to that type. That is, it might make sense to move the <code>enum FooOptions</code> into <code>class Foo</code> as simply <code>Options</code>. Note that structs cannot contain enum, flag, or delegate definitions; only constants and static methods.</li><li>Use header files and directories as a guide. If the headers are stored as <code>foo-2.0/db/{handle,transaction,row}.h</code> or <code>foo-2.0/db_{handle,transaction,row}.h</code> or if <code>foo-2.0/db.h</code> contains definitions for <code>foo_handle</code>, <code>foo_tx</code>, and <code>foo_row</code>, there&#39;s a good chance that creating a namespace <code>Db</code> is a logical grouping.</li><li>Create namespaces for large groups of related constants. Sometimes, constant collections cannot be converted to enums, in which case, grouping them into a namespace is much easier to manage.</li></ul>`,9)])])}const k=e(t,[["render",o]]);export{g as __pageData,k as default};
