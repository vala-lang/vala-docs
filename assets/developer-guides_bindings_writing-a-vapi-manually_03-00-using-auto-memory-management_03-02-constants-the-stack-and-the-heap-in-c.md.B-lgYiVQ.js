import{_ as t,c as a,o,ag as n}from"./chunks/framework.B-XtCDNB.js";const p=JSON.parse('{"title":"3.2. Constants, the Stack and the Heap in C","description":"","frontmatter":{},"headers":[],"relativePath":"developer-guides/bindings/writing-a-vapi-manually/03-00-using-auto-memory-management/03-02-constants-the-stack-and-the-heap-in-c.md","filePath":"developer-guides/bindings/writing-a-vapi-manually/03-00-using-auto-memory-management/03-02-constants-the-stack-and-the-heap-in-c.md","lastUpdated":1767920386000}'),i={name:"developer-guides/bindings/writing-a-vapi-manually/03-00-using-auto-memory-management/03-02-constants-the-stack-and-the-heap-in-c.md"};function s(d,e,r,l,h,c){return o(),a("div",null,[...e[0]||(e[0]=[n('<h1 id="_3-2-constants-the-stack-and-the-heap-in-c" tabindex="-1">3.2. Constants, the Stack and the Heap in C <a class="header-anchor" href="#_3-2-constants-the-stack-and-the-heap-in-c" aria-label="Permalink to &quot;3.2. Constants, the Stack and the Heap in C&quot;">â€‹</a></h1><p>Data in C can be allocated using a mechanism that stops it from being changed during the running of the program. These are known as constants. Data can also be allocated using two other schemes: the stack and the heap. These three schemes need to be understood when writing a binding. The main reason is so heap memory is allocated and deallocated properly by Vala code when using the binding, but also to make sure the binding doesn&#39;t apply heap rules to the other two schemes.</p><p>To better understand these three schemes it is helpful to analyse how they handle memory in four stages:</p><ol><li>Declaration</li><li>Allocation</li><li>Initialization</li><li>Deallocation</li></ol><p>Declaration informs the compiler of how much memory will be needed. For example <code>uint8</code> lets the compiler know at least 8 bits (a byte) is needed, or <code>double</code> will likely require more memory than <code>float</code>. The exact size of each type is platform dependent and will be resolved by the compiler.</p><p>Allocation is the process of exclusively reserving an area of memory. Where the memory is allocated from is based on the memory scheme.</p><p>Once the memory has been allocated the memory needs to be initialized to the required value. For example <code>int a = 128;</code> will set the memory reserved for an <code>int</code> to the value of <code>128</code>.</p><p>Deallocating the memory means it can be used again by other parts of the program.</p><table tabindex="0"><thead><tr><th></th><th>Declaration</th><th>Allocation</th><th>Initialization</th><th>Deallocation</th></tr></thead><tbody><tr><td><strong>Constant</strong></td><td>Compile time</td><td>Compiler</td><td>Compile time</td><td>Program exit</td></tr><tr><td><strong>Stack</strong></td><td>Compile time</td><td>Compiler</td><td>Run time</td><td>Compiler</td></tr><tr><td><strong>Heap</strong></td><td>Compile time</td><td>Coder</td><td>Run time</td><td>Coder</td></tr></tbody></table><p>The C compiler does some memory management. This happens when items are placed on the stack or inside another structure: the compiler creates the space needed to hold these objects. Otherwise, <code>malloc</code> and <code>free</code> are used to allocate space from the heap. If any instance contains references to other instances, helper functions are needed to do the allocate and deallocate those references.</p>',10)])])}const u=t(i,[["render",s]]);export{p as __pageData,u as default};
