import{_ as e,c as n,o as d,ag as a}from"./chunks/framework.B-XtCDNB.js";const h=JSON.parse('{"title":"3.4. Binding to C Heap Handlers","description":"","frontmatter":{},"headers":[],"relativePath":"developer-guides/bindings/writing-a-vapi-manually/03-00-using-auto-memory-management/03-04-binding-to-c-heap-handnlers.md","filePath":"developer-guides/bindings/writing-a-vapi-manually/03-00-using-auto-memory-management/03-04-binding-to-c-heap-handnlers.md","lastUpdated":1760471362000}'),o={name:"developer-guides/bindings/writing-a-vapi-manually/03-00-using-auto-memory-management/03-04-binding-to-c-heap-handnlers.md"};function r(i,t,s,c,u,l){return d(),n("div",null,[...t[0]||(t[0]=[a('<h1 id="_3-4-binding-to-c-heap-handlers" tabindex="-1">3.4. Binding to C Heap Handlers <a class="header-anchor" href="#_3-4-binding-to-c-heap-handlers" aria-label="Permalink to &quot;3.4. Binding to C Heap Handlers&quot;">â€‹</a></h1><p>One of the unique features of Vala is to have both singly-owned instances and reference-counted instances. Reference-counted instances can be stored in new locations and memory management done by counting the number of references; destruction of the instance is done when there are no more references to that instance. Singly-owned instances have a single authoritative reference and, when that reference is destroyed, the instance is destroyed. Reference-counted objects can thus be &quot;copied&quot; by increasing the reference count while singly-owned instances cannot be copied without duplicating the actual data in them, if that is even possible.</p><p>While this is primarily a concern for objects, all instances in Vala must subscribe to one of these memory management schemes. Different types of objects can follow different schemes and some types can subscribe to different schemes depending on subtle differences in declaration.</p><table tabindex="0"><thead><tr><th><strong>Vala Type</strong></th><th><strong>Scheme</strong></th><th><strong>C Type</strong></th><th><strong>Memory Management Binding Needed?</strong></th></tr></thead><tbody><tr><td>Enum and Flag</td><td>Value</td><td>int</td><td>No</td></tr><tr><td>Delegate <code>(has_target = false)</code></td><td>Value</td><td>Function Pointer</td><td>No</td></tr><tr><td>Delegate <code>(has_target = true)</code></td><td>Value</td><td>Function Pointer and Void Pointer</td><td>No</td></tr><tr><td>Delegate <code>(has_target = true)</code></td><td>Singly-Owned</td><td>Function Pointer and Void Pointer</td><td>Yes, use <code>free_function</code></td></tr><tr><td>Simple-Type Struct</td><td>Value</td><td>Various Basic Types or a Struct</td><td>No</td></tr><tr><td>Struct</td><td>Value</td><td>Struct, but passed as a Pointer to a Struct</td><td>No</td></tr><tr><td>Struct</td><td>Parented</td><td>Struct, but passed as a Pointer to a Struct</td><td>Yes, use <code>destroy_function</code></td></tr><tr><td>Compact Class</td><td>Singly-Owned</td><td>Pointer to a Struct</td><td>Yes, use <code>free_function</code></td></tr><tr><td>Compact Class</td><td>Reference-Counted</td><td>Pointer to a Struct</td><td>Yes, use <code>ref_function</code> and <code>unref_function</code></td></tr><tr><td>Pointer</td><td>Value</td><td>Pointer to Contents</td><td>No</td></tr><tr><td>Array</td><td>Singly-Owned</td><td>Pointer to Element Type (and Integer Length)</td><td>Yes, use <code>free_function</code></td></tr></tbody></table>',4)])])}const m=e(o,[["render",r]]);export{h as __pageData,m as default};
