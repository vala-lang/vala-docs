import{_ as n,c as t,o as a,ag as r}from"./chunks/framework.B-XtCDNB.js";const u=JSON.parse('{"title":"5.2. Ownership","description":"","frontmatter":{},"headers":[],"relativePath":"developer-guides/bindings/writing-a-vapi-manually/05-00-fundamentals-of-binding-a-c-function/05-02-ownership.md","filePath":"developer-guides/bindings/writing-a-vapi-manually/05-00-fundamentals-of-binding-a-c-function/05-02-ownership.md","lastUpdated":1760471362000}'),i={name:"developer-guides/bindings/writing-a-vapi-manually/05-00-fundamentals-of-binding-a-c-function/05-02-ownership.md"};function o(s,e,d,l,p,c){return a(),t("div",null,[...e[0]||(e[0]=[r('<h1 id="_5-2-ownership" tabindex="-1">5.2. Ownership <a class="header-anchor" href="#_5-2-ownership" aria-label="Permalink to &quot;5.2. Ownership&quot;">â€‹</a></h1><p>All parameters are, by default, unowned, unless marked with the <code>owned</code> keyword. All return values and <code>ref</code> and <code>out</code> parameters are, by default, owned, unless marked with the <code>unowned</code> keyword. The basic types mentioned above have no ownership since they may be copied at will.</p><p>It is often the case that a function will return one of its input values, particularly when filling a buffer. It is crucial that the ownership is correct. If not done correctly, Vala will acquire a second copy of the pointer that it thinks it has to free, and free the same chunk of memory twice, leaking to a bad time spent in Valgrind.</p><p><strong>If ownership semantics are not correct, either a memory leak has been written or a double-free has been written.</strong> It is frequently the case that one needs to read the source to be absolutely sure that ownership semantics are correct.</p><p>Often C programmers will mark return values as const when they are unowned.</p><p>See also: <a href="./../10-00-awkward-situations/10-02-dependently-typed-ownership.html">Dependently Typed Ownership</a>.</p>',6)])])}const w=n(i,[["render",o]]);export{u as __pageData,w as default};
