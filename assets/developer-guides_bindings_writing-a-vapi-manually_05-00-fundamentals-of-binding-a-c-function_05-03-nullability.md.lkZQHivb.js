import{_ as a,c as i,o as e,ag as n}from"./chunks/framework.B-XtCDNB.js";const c=JSON.parse('{"title":"5.3. Nullability","description":"","frontmatter":{},"headers":[],"relativePath":"developer-guides/bindings/writing-a-vapi-manually/05-00-fundamentals-of-binding-a-c-function/05-03-nullability.md","filePath":"developer-guides/bindings/writing-a-vapi-manually/05-00-fundamentals-of-binding-a-c-function/05-03-nullability.md","lastUpdated":1760471362000}'),t={name:"developer-guides/bindings/writing-a-vapi-manually/05-00-fundamentals-of-binding-a-c-function/05-03-nullability.md"};function l(p,s,h,o,r,k){return e(),i("div",null,[...s[0]||(s[0]=[n(`<h1 id="_5-3-nullability" tabindex="-1">5.3. Nullability <a class="header-anchor" href="#_5-3-nullability" aria-label="Permalink to &quot;5.3. Nullability&quot;">â€‹</a></h1><p>For most types, appending a question mark allows the type to be null. Generally, C programmers do a lousy job of conveying whether a particular parameter may be null. For any type which is, underneath, a pointer (arrays, compact classes, arrays, and delegates) nullability does not change the C type. That is, if <code>Foo</code> is a class, then <code>Foo foo</code> and <code>Foo? foo</code> have the same C signature. For simple types, enums, and flags, adding nullability lifts the type to a pointer. That is <code>bool b</code> has the C type <code>gboolean b</code> and <code>bool? b</code> has the C type <code>gboolean *b</code>. Parented structs are a special case. When passed as parameters, they are always passed as a pointer, so nullability makes only a semantic difference; when return values, nullability changes the behaviour, as discussed below.</p><p>Vala always assume an out parameter can be null. For example:</p><div class="language-vala vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vala</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> delegate</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ComputeFunc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> get_compute_func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">double</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> epsilon, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">out</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ComputeFunc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> func);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ComputeFunc</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> f;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get_compute_func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3.14158</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">out</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> f);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">f</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// f should never be a null pointer.</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get_compute_func</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2.72</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// This is perfectly okay according to Vala.</span></span></code></pre></div><p>It&#39;s important to note that nullability refers to the type of the parameter, not the parameter handling. Many C libraries do not check that an out parameter is not null before accessing it, resulting in a segmentation fault. There is no syntax in Vala to prevent this.</p>`,5)])])}const u=a(t,[["render",l]]);export{c as __pageData,u as default};
