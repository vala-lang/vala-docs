import{_ as n,c as i,o as s,j as t,a as e}from"./chunks/framework.B-XtCDNB.js";const p=JSON.parse('{"title":"5.4. Static Methods","description":"","frontmatter":{},"headers":[],"relativePath":"developer-guides/bindings/writing-a-vapi-manually/05-00-fundamentals-of-binding-a-c-function/05-04-static-methods.md","filePath":"developer-guides/bindings/writing-a-vapi-manually/05-00-fundamentals-of-binding-a-c-function/05-04-static-methods.md","lastUpdated":1759843583000}'),o={name:"developer-guides/bindings/writing-a-vapi-manually/05-00-fundamentals-of-binding-a-c-function/05-04-static-methods.md"};function d(c,a,l,r,h,m){return s(),i("div",null,[...a[0]||(a[0]=[t("h1",{id:"_5-4-static-methods",tabindex:"-1"},[e("5.4. Static Methods "),t("a",{class:"header-anchor",href:"#_5-4-static-methods","aria-label":'Permalink to "5.4. Static Methods"'},"â€‹")],-1),t("p",null,[e("Enums, flags, simple types, structs and classes can contain functions. When the Vala compiler generates the C function call the data structure will be included as the first argument. To prevent the automatic generation of the argument use the "),t("code",null,"static"),e(" keyword with the function definition in the VAPI.")],-1),t("p",null,"Binding static methods is, in fact, simpler than binding member methods, as there is no instance. Care should be taken to organise static methods into logical places: some should be in the containing namespace and some should be in the type definition. In general, methods that produce instances of the type (i.e., things that act like constructors that might fail) belong in the type definition.",-1)])])}const f=n(o,[["render",d]]);export{p as __pageData,f as default};
