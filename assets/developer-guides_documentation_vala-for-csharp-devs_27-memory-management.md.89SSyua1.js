import{_ as a,c as r,o as n,ag as t}from"./chunks/framework.B-XtCDNB.js";const g=JSON.parse('{"title":"Memory Management","description":"","frontmatter":{},"headers":[],"relativePath":"developer-guides/documentation/vala-for-csharp-devs/27-memory-management.md","filePath":"developer-guides/documentation/vala-for-csharp-devs/27-memory-management.md","lastUpdated":1765576003000}'),o={name:"developer-guides/documentation/vala-for-csharp-devs/27-memory-management.md"};function s(i,e,m,c,d,l){return n(),r("div",null,[...e[0]||(e[0]=[t('<h1 id="memory-management" tabindex="-1">Memory Management <a class="header-anchor" href="#memory-management" aria-label="Permalink to &quot;Memory Management&quot;">â€‹</a></h1><p>C#: Garbage collection</p><p>Vala: Automatic reference counting</p><p>This has both <a href="https://en.wikipedia.org/wiki/Reference_counting#Advantages_and_disadvantages" target="_blank" rel="noreferrer">advantages and disadvantages</a>. Reference counting is deterministic, but you can form reference cycles in some cases. In these cases you must use <a href="https://en.wikipedia.org/wiki/Weak_reference" target="_blank" rel="noreferrer">weak references</a> in order to break those cycles. The Vala keyword for this is <code>weak</code>.</p><p>See <a href="https://wiki.gnome.org/Projects/Vala/ReferenceHandling" target="_blank" rel="noreferrer">Vala&#39;s Memory Management Explained</a></p>',5)])])}const _=a(o,[["render",s]]);export{g as __pageData,_ as default};
