import{_ as a,c as t,o as i,ag as n}from"./chunks/framework.B-XtCDNB.js";const p=JSON.parse('{"title":"2.2. Syntax Overview","description":"","frontmatter":{},"headers":[],"relativePath":"tutorials/programming-language/main/02-00-basics/02-02-syntax-overview.md","filePath":"tutorials/programming-language/main/02-00-basics/02-02-syntax-overview.md","lastUpdated":1762883518000}'),o={name:"tutorials/programming-language/main/02-00-basics/02-02-syntax-overview.md"};function r(s,e,c,d,h,l){return i(),t("div",null,[...e[0]||(e[0]=[n('<h1 id="_2-2-syntax-overview" tabindex="-1">2.2. Syntax Overview <a class="header-anchor" href="#_2-2-syntax-overview" aria-label="Permalink to &quot;2.2. Syntax Overview&quot;">â€‹</a></h1><p>Vala&#39;s syntax is an amalgam heavily based on C#&#39;s. As a result, most of this will be familiar to programmers who know any C-like language, and in light of this I have kept things brief.</p><p>Scope is defined using braces. An object or reference is only valid between <code>{</code> and <code>}</code>. These are also the delimiters used to define classes, methods, code blocks etc, so they automatically have their own scope. Vala is not strict about where variables are declared.</p><p>An identifier is defined by its type and a name, e.g. <code>int c</code> meaning an integer called <em>c</em>. In the case of value types this also creates an object of the given type. For reference types these just define a new reference that doesn&#39;t initially point to anything.</p><p>Identifier names may be any combination of letters ([a-z], [A-Z]), underscores and digits. However, to define or refer to an identifier with a name that either starts with a digit or is a keyword, you must prefix it with the &#39;@&#39; character. This character is not considered a part of the name. For example, you can name a method <em>foreach</em> by writing <code>@foreach</code>, even though this is a reserved Vala keyword. You can omit the &#39;@&#39; character when it can be unambiguously interpreted as an identifier name, such as in &quot;foo.foreach()&quot;.</p><p>Reference types are instantiated using the <code>new</code> operator and the name of a construction method, which is usually just the name of the type, e.g. <code>Object o = new Object()</code> creates a new Object and makes <em>o</em> a reference to it.</p>',6)])])}const f=a(o,[["render",r]]);export{p as __pageData,f as default};
