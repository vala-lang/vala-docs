import{_ as i,c as a,o as n,ag as e}from"./chunks/framework.B-XtCDNB.js";const g=JSON.parse('{"title":"3.4. Signals","description":"","frontmatter":{},"headers":[],"relativePath":"tutorials/programming-language/main/03-00-object-oriented-programming/03-04-signals.md","filePath":"tutorials/programming-language/main/03-00-object-oriented-programming/03-04-signals.md","lastUpdated":1765576003000}'),t={name:"tutorials/programming-language/main/03-00-object-oriented-programming/03-04-signals.md"};function l(h,s,p,r,k,d){return n(),a("div",null,[...s[0]||(s[0]=[e(`<h1 id="_3-4-signals" tabindex="-1">3.4. Signals <a class="header-anchor" href="#_3-4-signals" aria-label="Permalink to &quot;3.4. Signals&quot;">â€‹</a></h1><p>Signals are a system provided by the Object class in GLib, and made easily accessible by Vala to all descendants of Object. A signal is recognisable to C# programmers as an event, or to Java programmers as an alternative way of implementing event listeners. In short, a signal is simply a way of executing an arbitrary number of externally identical methods (i.e. ones with the same signature) at approximately the same time. The actual methods of execution are internal to <em>gobject</em>, and not important to Vala programs.</p><p>A signal is defined as a member of a class, and appears similar to a method with no body. Signal handlers can then be added to the signal using the <code>connect()</code> method. In order to dive right in at the deep end, the following example also introduces lambda expressions, a very useful way to write signal handling code in Vala:</p><div class="language-vala vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vala</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> : </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">GLib</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Object</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> signal</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sig_1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> static</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> int</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[] args) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        Test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t1 = </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        t1.sig_1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">connect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((t, a) =&gt; {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            stdout.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;%d</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, a);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        t1.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">sig_1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>This code introduces a new class called &quot;Test&quot;, using familiar syntax. The first member of this class is a signal, called &quot;sig_1&quot;, which is defined as passing an integer. In the main method of this program, we first create a Test instance - a requirement since signals always belong to instances of classes. Next, we assign to our instance&#39;s &quot;sig_1&quot; signal a handler, which we define inline as a lambda expression. The definition states that the method will receive two arguments which we call &quot;t&quot; and &quot;a&quot;, but do not provide types for. We can be this terse because Vala already knows the definition of the signal and can therefore understand what types are required.</p><p>The reason there are two parameters to the handler is that whenever a signal is emitted, the object on which it is emitted is passed as the first argument to the handler. The second argument is that one that the signal says it will provide.</p><p>Finally, we get impatient and decide to emit a signal. We do this by calling the signal as though it was a method of our class, and allow gobject to take care of forwarding the message to all attached handlers. Understanding the mechanism used for this is not required to use signals from Vala.</p><p>NB: Currently the <code>public</code> access modifier is the only possible option - all signals can be both connected to and emitted by any piece of code.</p><p>Signals can be annotated with any combination of flags:</p><div class="language-vala vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vala</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Signal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (action=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, detailed=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, run=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, no_recurse=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, no_hooks=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> signal</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> sig_1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ();</span></span></code></pre></div><p>More samples in <a href="https://wiki.gnome.org/Projects/Vala/SignalsAndCallbacks" target="_blank" rel="noreferrer">Signal Samples</a>.</p>`,11)])])}const c=i(t,[["render",l]]);export{g as __pageData,c as default};
